import pandas as pd
import numpy as np


# pd.Series(집합적 자료형)
# pd.Series(리스트)
s = pd.Series([1, 2, 3])
print(s)
# 위 코드는 시리즈 생성 시 인덱스를 명시하지 않았음. 0 base 인덱스 생성


# pd.Series(튜플)
s = pd.Series((1.0, 2.0, 3.0))
print(s)


# pd.Series(1,2,3) # 시리즈 생성시 반드시 집합적 자료형을 이용해야 함
s2 = pd.Series(['a','a','c']) #dtype: object
print(s2)


# 리스트내에 서로 다른 type의 data가 있으면 형변환 일어남- 문자열로 변환됨
s_1 = pd.Series(['a', 1, 3.0]) #dtype: object
print(s_1)


# index 인수를 설정하지 않아서 0부터 시작됨
s = pd.Series(range(10, 14))
print(s)



# NaN은 np.nan 속성을 이용해서 생성
s = pd.Series([1, 2, 3, np.nan, 6, 8])
print(s)
# dtype: float64
# 판다스가 처리하는 자료구조인 시리즈와 데이터프레임에서 결측치가 있는 경우는 datatype이 float으로 변환함


# 인덱스를 지정해 주면 지정된 인덱스로 표현해줌
s = pd.Series([10, 20, 30], index = [1, 2, 3]) 
print(s)
# dtype: int64


# 인덱스를 문자열로 지정해 줄 수도 있음
s = pd.Series([95, 100, 88], index = ['홍길동', '이몽룡', '성춘향'])
print(s)
# dtype: int64


# 지정된 인덱스를 확인 하는 방법
s0 = pd.Series([10, 20, 30], index = [1, 2, 3])
print(s0.index)
# Index([1, 2, 3], dtype = 'int64')


s00 = pd.Series([1, 2, 3]) # index를 명시하지 않음
print(s00.index) # 범위 인덱스가 생성
# RangeIndex(start=0, stop=3, step=1)


s = pd.Series([9904312, 3448737, 289045, 2466052], index=["서울", "부산", "인천", "대구"])
print(s.index)
# 문자열형 인덱스. Index(['서울', '부산', '인천', '대구'], dtype='object')


# 시리즈의 값의 전체 형태는 array(numpy의 자료구조) 형태 
print(type(s.values))
# <class 'numpy.ndarray'>


# 데이터의 값이 바뀌는 것이 아니라, 인덱스 열의 '제목'을 달아주는 것
# s.name = '인구' # 값(Value)들이 담긴 데이터 자체의 이름을 '인구'로 설정. 
# 나중에 이 시리즈가 데이터프레임의 한 열(Column)이 될 때, 이 이름이 '컬럼명'이 됨
s.index.name = '광역시'


# 문자형 인덱스로 접근하려면
print(s['인천'])


# 위치 인덱스 사용 가능 (추후 지원 종료로 인하여 iloc사용 권고)
print(s[2])


# "Integer Location"을 명시하여 2번째 위치의 값을 가져옴.
# 숫자로 순서를 따질 때는 무조건 iloc를 쓰는 습관을 들이는 것을 권장!
print(s.iloc[2])


# 0번째와 3번째 값을 둘 다 보고 싶을 때 리스트 형태로 감싸서 전달해야 함
print(s.iloc[[0, 3]])


# 대괄호 안에 쉼표로 숫자만 나열하면 튜플 (0, 3, 1)이라는 '하나의 키'를 찾는 것으로 인식함
# 하지만 인덱스에 (0, 3, 1)이라는 이름은 없으므로 KeyError가 발생합니다.
print(s[0, 3, 1])


# 시리즈명[[인덱스리스트]]
# 현재는 시리즈형태로 반환되지만 향후 버전에서는 지원하지 않을 예정
# `ser.iloc[pos]`를 사용 권장
print(s[[0, 3, 1]])
# 인덱스 리스트 내의 해당 인덱스의 item을 추출 후 시리즈 형태로 반환


# 앞에 iloc를 붙여서 "나는 순서로 찾을 거야"라고 명시
# 판다스에서 s[[0, 3, 1]]처럼 대괄호 []를 사용하여 숫자(위치)로 데이터를 조회할 때 FutureWarning이 발생하는 이유는 
# 판다스 개발팀이 "대괄호 []의 역할을 명확하게 구분짓기 위해서" 정책을 바꾸고 있기 때문입니다.
# 쉽게 말해, "순서(번호)로 찾을 거면 제발 iloc를 붙여줘!" 라고 경고하는 것입니다.
# 판다스의 [] 연산자는 그동안 너무 많은 일을 해왔습니다.
# 이름(Label)으로도 찾고 (loc 역할)
# 순서(Position)로도 찾고 (iloc 역할)
# 이렇다 보니 인덱스가 숫자인 경우 컴퓨터가 헷갈리는 상황이 발생합니다.
print(s.iloc[[0, 3, 1]])



# 정수형 인덱스인 경우
s03 = pd.Series([1, 2, 3], index=[10, 11, 12])
print(s03)
print(s03[10]) # 명시적 인덱스(정수인덱스임) 사용
# print(s03[0]) # 위치인덱스 접근 - KeyError
# 정수인덱스인 경우 위치인덱스는 사용 불가

# [iloc 순서 기반 추출] iloc를 사용하여 1차원 Series에서 특정 위치의 값들을 추출
# "iloc"는 '위치'를 기준으로 하며, 대괄호 안에 [1, 2] 리스트를 넣어 1번째(부산)와 2번째(인천) 데이터를 추출
print(s.iloc[[1, 2]])


# [라벨 기반 팬시 인덱싱] 인덱스 이름('부산', '인천')을 "리스트 형태"로 전달하여 해당 값들만 추출합니다.
# "s.loc[['부산', '인천']]"을 사용하는 것과 완전히 동일한 기능입니다.
# 추출된 결과는 새로운 Series 객체로 반환되며, 순서는 리스트에 입력된 순서를 따릅니다.
print(s[['부산', '인천']])


# [슬라이싱 출력] 위치 인덱스(0부터 시작)를 사용하여 1번째부터 3번째 '전'까지의 데이터를 추출
# 파이썬 슬라이싱 규칙에 따라 시작 인덱스 1 (부산)은 포함하고, 끝 인덱스 3 (대구)은 제외합니다.
# 결과: 부산과 인천의 데이터가 추출됩니다. (위치 1, 2)
print(s[1:3])


# [라벨 슬라이싱] 인덱스 이름('부산')부터 '대구'까지의 데이터를 추출하여 출력합니다.
# 주의! 문자열 라벨을 이용한 슬라이싱은 파이썬 리스트와 달리 끝 라벨도 포함(Inclusive)합니다.
# 결과는 '부산', '인천', '대구'의 데이터입니다.
print(s["부산":"대구"])


# [시리즈 생성] 값(100, 200...)과 인덱스 라벨(1, 2, 3, 4)이 모두 정수인 Series 객체 s_01을 생성합니다.
s_01 = pd.Series([100,200,300,400], index=[1,2,3,4])
print(s_01)


# [팬시 인덱싱] 리스트([2, 3, 4])를 사용하여 여러 개의 값을 한 번에 추출합니다.
# 인덱스 라벨 자체가 정수이므로, Pandas는 이것을 '위치'가 아닌 '라벨 이름'으로 인식하고 해당 라벨의 값을 가져옵니다.
# 결과: 라벨 2, 3, 4에 해당하는 값 200, 300, 400을 포함하는 새로운 시리즈가 생성됩니다.
print(s_01[[2, 3, 4]])


# [시리즈 생성] range(3) 함수를 사용하여 값 [0, 1, 2]를 생성하고,
# 이 값들에 문자열 리스트 ['a', 'b', 'c']를 인덱스 라벨로 지정하여 Series 객체 's0'를 생성합니다.
s0 = pd.Series(range(3), index=['a', 'b', 'c'])
print(s0)


# [라벨 인덱싱] 대괄호([])를 사용하여 인덱스 라벨 'a'에 해당하는 값을 추출합니다.
# (출력값: 0)
print(s0['a'])


# [속성 접근] 점(.)을 사용하여 Series의 속성(Attribute)처럼 인덱스 라벨 'a'에 해당하는 값을 추출합니다.
# (출력값: 0) 
# 주의: 이 방법은 인덱스 라벨이 'a'처럼 파이썬 변수명 규칙을 따를 때만 사용할 수 있는 간편한 방식입니다.
print(s0.a)


# [라벨 인덱싱] 대괄호([])를 사용하여 인덱스 라벨 '서울'에 해당하는 값을 추출합니다.
# 이 방식은 가장 표준적이며, 인덱스 라벨이 어떤 문자이든 상관없이 항상 작동합니다.
# (출력값: 9904312)
print(s['서울'])


# [속성 접근] 점(.)을 사용하여 Series의 속성(Attribute)처럼 인덱스 라벨 '서울'에 해당하는 값을 추출합니다.
# 주의: 이 방법은 라벨('서울')이 파이썬 변수명 규칙을 따를 때만 사용할 수 있는 간편한 방식입니다.
# (출력값: 9904312)
print(s.서울)


# [값 변경/수정] 인덱스 라벨 '서울'을 사용하여 해당 위치의 값을 10000000으로 수정합니다.
# 시리즈는 mutable(가변)하므로, 특정 라벨을 지정하여 값을 덮어쓸 수 있습니다.
s['서울'] = 10000000
print(s.서울)


# 문자 인덱스의 시리즈 s 확인 후 연산 실습
print(s)


# [값 확인] 수정된 값(10000000)을 확인하기 위해 인덱스 라벨 '서울'의 값을 출력합니다.
# 출력값: 10000000
print(s['서울'])


# [인덱스 확인] 시리즈 s의 인덱스(행 라벨) 목록을 출력합니다.
# 출력: Index(['서울', '부산', '인천', '대구'], dtype='object')
print(s.index)
s1 = pd.Series(np.arange(4), s.index)
# [시리즈 s1 생성] numpy의 arange 함수를 이용해 0부터 3까지의 정수(0, 1, 2, 3)를 값으로 만듭니다.
# 그리고 이전에 생성한 시리즈 s의 인덱스(s.index, 즉 서울, 부산, 인천, 대구)를 그대로 재사용하여
# 새로운 시리즈 s1을 생성합니다.


# [s1 출력] 새로 생성된 시리즈 s1을 출력합니다.
# 인덱스는 s와 같고 값은 0부터 시작하는 새로운 시리즈입니다.
print(s1)


# [시리즈 생성 및 출력] pd.Series([1, 2, 3])를 생성합니다. (인덱스는 0, 1, 2가 자동으로 부여됨)
# [스칼라 연산] 생성된 시리즈의 '모든 값'에 숫자 4를 더합니다.
# 이처럼 시리즈의 각 요소에 하나의 숫자(스칼라)를 연산하는 것을 '브로드캐스팅(Broadcasting)'이라고 합니다.
# 결과: 인덱스 0에는 1 + 4 = 5, 인덱스 1에는 2 + 4 = 6, 인덱스 2에는 3 + 4 = 7이 됩니다.
print(pd.Series([1, 2, 3]) + 4)


# [브로드캐스팅 연산 및 출력] 시리즈 's'의 모든 요소(값)를 1,000,000으로 나눕니다.
# '브로드캐스팅'을 통해 각 인구수를 100만 단위로 변환한 결과를 출력합니다.
print(s/1000000)









# [불리언 인덱싱] 조건을 만족하는 값만 추출하여 새로운 시리즈를 출력합니다.
# 조건 해석:
#   - s > 250e4 : 2,500,000 (250만)보다 큰 값
#   - s < 500e4 : 5,000,000 (500만)보다 작은 값
#   - & 연산자 : 두 조건을 모두 만족하는 (AND) 값만 선택
# 결과: 250만 초과, 500만 미만에 해당하는 '부산(3,448,737)'과 '대구(2,466,052)'가 추출되어야 하지만,
# 대구는 250만보다 작으므로 조건을 만족하지 못합니다.
# (수정: 246만은 250만보다 작으므로 대구는 제외되어야 합니다. s > 250e4 조건에 의해 대구는 False입니다.)
# 최종 결과는 '부산'만 포함된 시리즈입니다.
print(s[(s>250e4) & (s<500e4)])


# [시리즈 s0 생성] Series 객체 s0을 생성합니다.
#   - 값 (첫 번째 인자): np.arange(10) -> 0부터 9까지의 정수 배열 ([0, 1, 2, ..., 9])
#   - 인덱스 (두 번째 인자): np.arange(10) + 1 -> 1부터 10까지의 정수 배열 ([1, 2, 3, ..., 10])
#   - 결과: 값은 0부터 시작하고, 인덱스는 1부터 시작하는 시리즈가 생성됩니다.
s0 = pd.Series(np.arange(10), np.arange(10)+1)
# print(s0)


# [논리 연산 및 출력] 시리즈 s0의 '각 값'이 5보다 큰지 비교하는 연산을 수행합니다.
# 이 연산은 시리즈의 모든 요소에 적용되며(브로드캐스팅), 결과는 True 또는 False로 이루어진 새로운 Series가 됩니다.
# 출력: True 또는 False로 구성된 불리언(Boolean) 시리즈
print(s0 > 5)


# [불리언 인덱싱 및 출력]
# s0 > 5: 시리즈 s0의 값이 5보다 큰지 확인하여, True/False로 이루어진 불리언 시리즈를 생성합니다.
#         (예: s0의 값 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 중 [F, F, F, F, F, F, T, T, T, T]가 됨)
# s0[...]: 이 불리언 시리즈를 인덱스로 사용하여, 값이 True인 데이터(6, 7, 8, 9)만 필터링하여 출력합니다.
print(s0[s0 > 5])


# [불리언 마스크 생성] 시리즈 s0의 값이 2로 나누어 나머지가 0인 경우(짝수인 경우)를 확인합니다.
# 이 결과는 True(짝수) 또는 False(홀수)로 구성된 '불리언 마스크(Boolean Mask)' 시리즈를 생성합니다.
# 예: [True, False, True, False, ...]
# [불리언 인덱싱 및 출력]
# s0[...] : 생성된 불리언 마스크를 시리즈 s0에 적용하여,
# 마스크 값이 True인 위치의 '데이터만' 필터링하여 출력합니다.
# 즉, s0에서 값이 짝수인 요소들만 추출됩니다.
print(s0[s0 % 2 == 0])



# [인덱스 대상 불리언 연산 및 출력]
# s0.index: Series의 인덱스 객체(1, 2, ..., 10)를 가져옵니다.
# > 5     : 인덱스의 각 요소가 5보다 큰지 확인하는 비교 연산을 일괄 적용합니다.
# 결과: 조건을 만족하는지 여부를 나타내는 불리언 배열(False/True의 목록)이 출력됩니다.
# (1, 2, 3, 4, 5는 False, 6, 7, 8, 9, 10은 True가 나옵니다.)
print(s0.index > 5)



# [불리언 인덱싱 및 출력] 논리 조건에 맞는 데이터만 필터링하여 출력합니다.
# 조건 해석:
#   - s0 > 5 : s0의 값(Value)이 5보다 큰가? (False, False, ..., True, True, True, False...)
#   - s0 < 8 : s0의 값(Value)이 8보다 작은가? (True, True, ..., True, False...)
#   - &      : 두 조건을 모두 만족하는가? (AND 연산)
# 최종 조건: 값이 5보다 크고 8보다 작은 값, 즉 값 6과 7만 선택됩니다.
# 값 6은 인덱스 7에, 값 7은 인덱스 8에 해당합니다.
print(s0[(s0 > 5) & (s0 < 8)])


# [불리언 연산] s0의 각 값이 7보다 크거나 같은지 확인합니다.
# 이 연산의 결과는 True/False로 이루어진 불리언(Boolean) 시리즈가 됩니다.
# True인 값: 7, 8, 9 (인덱스 8, 9, 10)
# False인 값: 0부터 6까지 (인덱스 1부터 7)
# (s0 >= 7)
# [합계 계산] 불리언 시리즈에 .sum()을 적용합니다.
# 판다스/넘파이에서 True는 숫자 1로, False는 숫자 0으로 처리됩니다.
# 따라서 .sum()은 True의 개수(즉, 조건(7 이상)을 만족하는 요소의 개수)를 계산합니다.
# 결과: 7, 8, 9 (3개)이므로 3이 출력됩니다.
print((s0 >= 7).sum())



# [복합 연산 및 출력] 불리언 인덱싱을 사용하여 조건을 만족하는 값만 합산합니다.
# -------------------------------------------------------------
#   (1) 내부 조건: (s0 >= 7)
#       -> s0의 값들 중 7 이상인 항목들을 True로 표시하는 불리언 마스크를 생성합니다. (True에 해당하는 값은 7, 8, 9)
#   (2) 인덱싱: s0[...]
#       -> 위 마스크를 s0에 적용하여 값 7, 8, 9만 포함하는 새로운 시리즈를 추출합니다.
#   (3) 집계: .sum()
#       -> 추출된 값들(7, 8, 9)의 총합을 계산합니다. (7 + 8 + 9 = 24)
# -------------------------------------------------------------
print((s0[s0 >= 7]).sum())










# [시리즈 생성] Series 객체 'num_s1'을 생성합니다.
#   - 값(데이터): [1, 2, 3, 4]를 담습니다.
#   - 인덱스 라벨: 인덱스(행의 이름)를 문자열 ['a', 'b', 'c', 'd']로 명시적으로 지정합니다.
num_s1=pd.Series([1, 2, 3, 4],index=['a', 'b', 'c', 'd'])
num_s2=pd.Series([5, 6, 7, 8],index=['b', 'c', 'd', 'a'])



# [시리즈 덧셈 및 출력] 두 시리즈를 더합니다.
# Pandas는 덧셈 연산 시 "인덱스 라벨을 기준으로 자동으로 정렬한 후" 같은 라벨끼리 요소를 더합니다.
# num_s1의 'a' (값 1) + num_s2의 'a' (값 8) = 9
# num_s1의 'b' (값 2) + num_s2의 'b' (값 5) = 7
# num_s1의 'c' (값 3) + num_s2의 'c' (값 6) = 9
# num_s1의 'd' (값 4) + num_s2의 'd' (값 7) = 11
print(num_s1 + num_s2)


num_s3=pd.Series([5,6,7,8],index=['e','b','f','g'])
num_s4=pd.Series([1,2,3,4],index=['a','b','c','d'])


# [시리즈 뺄셈 및 출력] num_s3에서 num_s4를 뺍니다.
# Pandas는 뺄셈 연산 시 "인덱스 라벨을 기준으로 자동 정렬"합니다.
# 인덱스가 "공통된 라벨"에 대해서만 연산이 가능하며, 공통되지 않은 라벨은 "결측값(NaN)"이 됩니다.
# 공통 라벨은 'b' 하나뿐입니다.
#   - 'b' 라벨: num_s3의 'b' (값 6) - num_s4의 'b' (값 2) = 4
#   - 나머지 라벨 (a, c, d, e, f, g): 공통되지 않으므로 NaN이 됩니다.
print(num_s3 - num_s4)


# [값 연산 및 출력]
#   - .values 속성 사용: num_s3와 num_s4의 "인덱스 라벨을 무시"하고 내부의 순수한 값(NumPy 배열)만 추출합니다.
#   - 연산: 두 배열을 순서대로 요소별(Element-wise)로 뺄셈합니다.
#   - 연산 과정: [5-1, 6-2, 7-3, 8-4]
#   - 결과: [4, 4, 4, 4]를 포함하는 NumPy 배열이 출력됩니다.
print(num_s3.values - num_s4.values)










# 너무 위에 있어서 보기 편하라고 63번라인 그대로 다시 씀.
s = pd.Series([9904312, 3448737, 289045, 2466052], index=["서울", "부산", "인천", "대구"])


# [인덱스 포함 여부 확인 및 출력] '서울'이라는 문자열이 시리즈 's'의 "인덱스 라벨"에 포함되어 있는지 확인합니다.
# 파이썬의 'in' 연산자는 시리즈에 적용될 때, 기본적으로 "인덱스 라벨을 검사"합니다.
# '서울'은 인덱스에 있으므로 True를 출력합니다.
print('서울' in s)


# [멤버십 확인 및 출력] '대전'이라는 라벨이 시리즈 s의 인덱스에 "포함되어 있는지(멤버인지)" 확인합니다.
# 파이썬의 'in' 연산자는 Series 객체에 적용될 때, 기본적으로 "인덱스 라벨" 목록을 확인합니다.
# '대전'은 인덱스 목록에 없으므로 False를 출력합니다.
print('대전' in s)


# [멤버십 확인 및 출력] '대전' 인덱스 라벨이 시리즈 's'에 포함되어 있지 않은지 확인합니다.
#   - '대전' in s : 대전이 인덱스에 포함되어 있는가? (False)
#   - not : 논리 연산자 not을 사용하여 결과를 반전시킵니다. (True)
# 최종 결과: '대전'이 s의 인덱스에 없으므로, True를 출력합니다.
print('대전' not in s)











# [items() 메서드 호출 및 출력]
# s.items()는 시리즈의 각 인덱스(Key)와 값(Value) 쌍을 튜플 형태로 반환하는 반복자(Iterator)를 생성합니다.
# 이 함수는 시리즈를 파이썬의 딕셔너리처럼 인덱스-값 쌍으로 순회할 때 주로 사용됩니다.
print(s.items())


# [items() 메서드 사용] Series의 .items() 메서드를 호출합니다.
# 이 메서드는 시리즈의 각 요소(인덱스 라벨과 값)를 파이썬의 튜플 (라벨, 값) 형태로 반환하는 반복자(iterator)를 생성합니다.
# [list() 변환 및 출력] 생성된 반복자를 list() 함수로 감싸서 최종적으로 (라벨, 값) 쌍을 가진 리스트로 변환하여 출력합니다.
print(list(s.items()))



# [반복문 시작] s.items() 메서드를 사용하여 시리즈의 모든 요소를 순회합니다.
#    - s.items()는 딕셔너리의 items()처럼 (인덱스 라벨, 값) 쌍을 튜플 형태로 반환합니다.
#    - k 변수에는 인덱스 라벨('서울', '부산' 등)이, v 변수에는 해당 값(인구수)이 차례로 저장됩니다.
    # [출력] print 함수와 문자열 포매팅('%s=%d')을 사용하여 "인덱스 라벨=값" 형태로 출력합니다.
    #    - %s: 문자열(k, 인덱스 라벨)을 위한 포맷 지정자
    #    - %d: 정수(v, 인구수)를 위한 포맷 지정자
for k, v in s.items() :
    print('%s = %d' % (k, v))



# [딕셔너리(Dictionary) 생성] 학생 이름(키, Key)을 점수(값, Value)와 짝지어 딕셔너리를 생성합니다.
scores = {'홍길동':96, '이몽룡':100, '성춘향':88}

# [시리즈(Series) 생성] 딕셔너리를 사용하여 Series 객체 's'를 생성합니다.
#    - 딕셔너리의 '키(Key)'는 Series의 인덱스 라벨(Index Label)이 됩니다. (홍길동, 이몽룡, 성춘향)
#    - 딕셔너리의 '값(Value)'은 Series의 데이터 값(Value)이 됩니다. (96, 100, 88)
s = pd.Series(scores)
print(s)



# [딕셔너리(Dictionary) 생성] 도시 이름(키, Key)을 인구수(값, Value)와 짝지어 딕셔너리를 생성합니다.
city = {'서울':9631482, '부산':3393191, '인천':2632035, '대전':1490158}

# [시리즈(Series) 생성] 딕셔너리를 사용하여 Series 객체 's'를 생성합니다.
#    - 딕셔너리의 '키(Key)'는 Series의 인덱스 라벨(Index Label, 즉 도시 이름)이 됩니다.
#    - 딕셔너리의 '값(Value)'은 Series의 데이터 값(Value, 즉 인구수)이 됩니다.
s = pd.Series(city)
print(s)



# [시리즈(Series) 생성] 딕셔너리 'city'를 사용하여 Series 객체 's'를 생성합니다.
#    - 첫 번째 인자 (city): 딕셔너리의 키와 값이 그대로 Series의 인덱스와 값이 됩니다.
#    - 두 번째 인자 (index = city.keys()): 인덱스 라벨을 명시적으로 city 딕셔너리의 키 목록(서울, 부산 등)으로 지정합니다.
#      (이 경우에는 첫 번째 인자만 써도 결과는 같지만, 명시적으로 지정하여 인덱스를 제어할 수 있음을 보여줍니다.)
s = pd.Series(city, index = city.keys())
print(s)



# [시리즈 생성 및 인덱스 재지정]
#    - 첫 번째 인자(city): 딕셔너리 'city'를 Series의 데이터로 사용합니다.
#    - 두 번째 인자(index=['...']): Series를 만들 때 인덱스의 순서를 명시적으로 ['부산', '인천', '서울', '대전']으로 지정합니다.
#    - Pandas는 딕셔너리 'city'에서 이 순서에 맞춰 데이터를 찾아 매핑합니다. (데이터 값은 원본 딕셔너리의 값을 따릅니다.)
s = pd.Series(city, index = ['부산', '인천', '서울', '대전'])
print(s)



# [요소 추가/수정] 딕셔너리처럼 대괄호(['마산'])를 사용하여 새로운 인덱스 라벨 '마산'에 값 15784567을 할당합니다.
# Series는 가변(mutable) 객체이므로, 존재하지 않는 라벨에 값을 할당하면 해당 요소가 시리즈의 맨 끝에 추가됩니다.
s['마산'] = 15784567
print(s)

# [데이터 삭제] Python의 'del' 키워드를 사용하여 시리즈에서 '마산' 인덱스 라벨과 그 값을 영구적으로 제거합니다.
#    - del 키워드 외에 .drop() 메서드를 사용할 수도 있지만, del이 가장 간결합니다.
del s['서울']
print(s)










# [시리즈 생성] 총 16개의 요소(마지막은 NaN)를 가진 Series 객체 s1을 생성합니다.
s1 = pd.Series([1, 1, 2, 1, 2, 2, 2, 1, 1, 3, 3, 4, 5, 5, 7, np.nan])
# print(s1)

# [len() 함수] Python 표준 len() 함수를 사용하여 시리즈의 총 길이(요소 개수)를 구합니다. (NaN 포함)
# 출력: 16
print(len(s1))


# [.size 속성] Pandas Series의 총 요소 개수를 반환합니다. (NaN 포함)
# 출력: 16 (len(s1)과 동일)
print(s1.size)


# [.shape 속성] Series의 차원(Dimension)을 튜플 형태로 반환합니다. (Series는 1차원이므로 튜플의 첫 요소만 사용됨)
# 출력: (16,)
print(s1.shape)


# [.unique() 메서드] Series 내부에 존재하는 중복되지 않는 고유한 값들을 NumPy 배열로 반환합니다. (NaN도 고유한 값으로 포함됨)
# 출력: array([ 1.,  2.,  3.,  4.,  5.,  7., nan])
print(s1.unique())


# [.count() 메서드] Series 내부에 존재하는 '결측치가 아닌 값 (Non-NaN)'의 개수를 계산합니다. (NaN 제외)
# 출력: 15 (총 16개 중 NaN 1개를 제외)
print(s1.count())










# [NumPy 배열 생성] 4개의 숫자 2와 1개의 결측치(np.nan)를 포함하는 NumPy 배열 'a'를 생성합니다. (총 5개 요소)
a = np.array([2, 2, 2, 2, np.nan])


# [NumPy 평균 계산] NumPy의 .mean() 메서드를 사용하여 배열 'a'의 평균을 계산합니다.
#    - NumPy는 기본적으로 결측치(NaN)를 계산에 포함하여 처리합니다.
#    - 결과: 산술 연산에 NaN이 포함되면 결과도 NaN이 됩니다.
print(a.mean())


# [Series 생성] NumPy 배열 'a'를 기반으로 Pandas Series 'b'를 생성합니다.
b = pd.Series(a)


# [Series 출력] 생성된 Series 'b'를 출력합니다.
print(b)



# [Pandas 평균 계산] Pandas Series의 .mean() 메서드를 사용하여 평균을 계산합니다.
#   - Pandas는 기본적으로 결측치(NaN)를 "자동으로 제외하고" 나머지 유효한 값들로만 평균을 계산합니다.
#   - 계산: (2 + 2 + 2 + 2) / 4 = 2.0
#   - 결과: 2.0
print(b.mean())











# [인덱스 리스트 생성] 날짜를 나타내는 문자열 리스트를 인덱스로 사용하기 위해 정의합니다.
index_date = ['2018-10-07', '2018-10-08', '2018-10-09', '2018-10-10']


# [시리즈 s4 생성]
#    - 값(데이터): [200, 195, np.nan, 205] 리스트를 사용합니다.
#      * 주목: 세 번째 요소에 "np.nan (Not a Number == 결측치)"을 포함시킵니다.
#    - 인덱스: 위에서 정의한 index_date 리스트를 사용하여 날짜 라벨을 부여합니다.
s4 = pd.Series([200, 195, np.nan, 205], index = index_date)
# print(s4)


# [인덱스 타입 확인] s4 시리즈의 인덱스 객체(s4.index) 중 첫 번째 요소([0])의 자료형을 확인하여 출력합니다.
#    - 판다스 시리즈를 생성할 때 명시적으로 dtype을 지정하지 않으면, 
#      문자열 리스트로 생성된 인덱스 요소는 기본적으로 'str' (문자열) 타입으로 유지됩니다.
# 출력: <class 'str'>
print(type(s4.index[0]))



# [날짜 범위 생성] pd.date_range() 함수를 사용하여 특정 기간의 날짜 시퀀스를 생성합니다.
#    - start='2018-10-01': 날짜 범위의 시작 날짜를 지정합니다. (포함)
#    - end='2018-10-20': 날짜 범위의 끝 날짜를 지정합니다. (포함)
#    - 기본 설정으로 하루(day) 간격으로 날짜를 생성합니다.
print(pd.date_range(start = '2018-10-01', end = '2018-10-20'))



# [날짜 범위 생성] pd.date_range 함수를 사용하여 특정 기간의 날짜/시간 인덱스를 생성합니다.
#    - start='2018-10-01': 날짜 범위의 시작 지점을 2018년 10월 1일로 설정합니다.
#    - end='2018-10-20': 날짜 범위의 끝 지점을 2018년 10월 20일로 설정합니다. (끝 날짜 포함)
#    - freq='D': Frequency(빈도)를 'Day'의 약자인 'D'로 설정하여, 날짜를 1일 간격으로 생성하도록 지정합니다.
print(pd.date_range(start = '2018-10-01', end = '2018-10-20', freq = 'D'))



# [날짜 범위 생성] pd.date_range 함수를 사용하여 특정 기간의 날짜/시간 인덱스를 생성합니다.
#    - start='2018-10-01': 날짜 범위의 시작 지점을 2018년 10월 1일로 설정합니다.
#    - end='2018-10-20': 날짜 범위의 끝 지점을 2018년 10월 20일로 설정합니다. (끝 날짜 포함)
#    - freq='3D': Frequency(빈도)를 '3D'로 설정하여, 날짜를 "3일 간격"으로 생성하도록 지정합니다.
print(pd.date_range(start = '2018-10-01', end = '2018-10-20', freq = '3D'))



# [날짜 범위 생성] pd.date_range 함수를 사용하여 특정 기간의 날짜/시간 인덱스를 생성합니다.
#    - start='2018-10-01': 날짜 범위의 시작 지점을 2018년 10월 1일로 설정합니다.
#    - end='2018-10-20': 날짜 범위의 끝 지점을 2018년 10월 20일로 설정합니다. (끝 날짜 포함)
#    - freq='W': Frequency(빈도)를 'Week'의 약자인 'W'로 설정하여, 날짜를 "1주일 간격"으로 생성하도록 지정합니다.
#      (특정 요일 지정이 없으면, 시작 날짜가 속한 주의 일요일(Sun)을 기준으로 다음 주 일요일들을 생성하는 것이 기본 동작입니다.)
print(pd.date_range(start = '2018-10-01', end = '2018-10-20', freq = 'W'))



# [날짜 범위 생성] pd.date_range 함수를 사용하여 날짜/시간 인덱스를 생성합니다.
#    - start='2018-10-01': 날짜 범위의 시작 지점을 2018년 10월 1일로 설정합니다.
#    - periods=4: 시작 날짜부터 총 4개의 기간(요소)을 생성하도록 지정합니다.
#    - freq='W': Frequency(빈도)를 'Week'의 약자인 'W'로 설정하여, 날짜를 "1주일(주) 간격"으로 생성하도록 지정합니다.
#      (W의 기본 동작은 그 주의 일요일(Sunday)을 기준으로 합니다.)
print(pd.date_range(start = '2018-10-01', periods = 4, freq = 'W'))



# [날짜 범위 생성] pd.date_range 함수를 사용하여 날짜/시간 인덱스를 생성합니다.
#    - start='2018-10-01': 날짜 범위의 시작 지점을 2018년 10월 1일로 설정합니다.
#    - periods=4: 시작 날짜부터 총 4개의 기간(요소)을 생성하도록 지정합니다.
#    - freq='M': Frequency(빈도)를 'Month End'의 약자인 'M'으로 설정하여, "매월 말일"을 기준으로 날짜를 생성하도록 지정합니다.
#      (시작 날짜와 관계없이, 이후 돌아오는 매월 말일 날짜를 4개 생성합니다.)
print(pd.date_range(start = '2018-10-01', periods = 4, freq = 'm'))




