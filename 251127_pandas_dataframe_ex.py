import pandas as pd
import numpy as np



# DataFrame을 생성합니다.
# 데이터는 리스트의 리스트 형태로 제공됩니다. 각 내부 리스트는 DataFrame의 한 행(row)이 됩니다.
# 1행: ['a', 'b', 'c']
# 2행: ['a', 'a', 'g']
# 3행: ['a', 'a'] -> 3열(인덱스 2)에 해당하는 값이 없으므로, 기본적으로 NaN(Not a Number, 결측값)으로 채워집니다.
df = pd.DataFrame([['a','b','c'],['a','a','g'],['a','a']])
print(df)



df1 = pd.DataFrame({ # DataFrame을 생성하고 그 결과를 변수 df1에 저장합니다.
    "A":[90, 80, 70], # 'A'라는 열(column)의 데이터: [90, 80, 70]
    "B":[85, 98, 75], # 'B'라는 열(column)의 데이터: [85, 98, 75]
    "C":[88, 99, 77], # 'C'라는 열(column)의 데이터: [88, 99, 77]
    "D":[87, 89, 86]  # 'D'라는 열(column)의 데이터: [87, 89, 86]
}, index=[1, 2, 3]) # index 매개변수를 사용하여 행(row)의 레이블(이름)을 [1, 2, 3]으로 설정합니다.
                    # 인덱스가 설정되지 않았다면 기본값인 [0, 1, 2]가 사용됩니다.

print(df1)



# CSV 파일 읽기
# pd.read_csv(): CSV(Comma Separated Values) 형식의 파일을 읽어와서 DataFrame 객체로 변환하는 함수입니다.
# './data/train.csv': 읽어올 파일의 경로입니다.
#    - '.'은 현재 작업 디렉토리(Current Working Directory)를 의미합니다.
#    - '/data/'는 현재 디렉토리 아래의 'data'라는 폴더를 의미합니다.
#    - 'train.csv'는 그 폴더 안에 있는 파일 이름입니다.
# train_data: CSV 파일에서 읽어온 데이터(DataFrame 객체)를 저장하는 변수입니다.
train_data = pd.read_csv('./data/train.csv')



train_data = pd.read_csv( # CSV 파일을 읽어와 DataFrame을 생성하고 변수 train_data에 저장합니다.
    './data/train.csv',  # 읽어올 파일의 경로와 이름입니다. (현재 디렉토리의 data 폴더 아래 train.csv 파일을 의미합니다.)
    index_col='PassengerId', # 'PassengerId' 열을 DataFrame의 행 인덱스(Row Index)로 지정합니다.
                             # 이렇게 하면 'PassengerId'가 데이터 열에서 제외되고 행을 식별하는 레이블이 됩니다.
    usecols=['PassengerId', 'Survived', 'Name', 'Sex', 'Age'] # CSV 파일에서 "사용할 열(Column)"만 명시적으로 선택합니다.
                                                              # 이 외의 다른 열은 DataFrame에 포함되지 않습니다.
)

print(train_data.columns) # 생성된 DataFrame 'train_data'의 열 이름들(컬럼 인덱스)을 리스트형태로 출력합니다.



# 데이터 확인
# train_data.head(): DataFrame의 가장 "처음 5줄(rows)"만 반환하는 메서드입니다.
# (인수가 없으면 기본 5줄을 반환하며, 괄호 안에 숫자를 넣으면 그 숫자만큼의 줄을 반환합니다. 예: .head(10))
# print(): 반환된 DataFrame의 일부 내용을 화면(콘솔)에 출력하여 데이터의 구조(열 이름, 첫 5개 행의 값)를 확인합니다.
print(train_data.head(0))




print(len(train_data))    # DataFrame의 길이를 출력합니다.
                          # pandas에서 len() 함수는 "행(Row)의 개수"를 반환합니다.
print(train_data.size)    # DataFrame의 size 속성을 출력합니다.
                          # "전체 요소(element)의 개수"를 반환합니다. (행의 개수 * 열의 개수)
print(train_data.shape)   # DataFrame의 shape 속성을 출력합니다.
                          # "(행의 개수, 열의 개수)"를 튜플 형태로 반환합니다.



print(train_data.info()) # train_data DataFrame에 대한 상세 정보를 출력합니다.
                         # 이 메서드는 다음 정보를 포함한 요약을 보여줍니다:
                         # 1. 클래스 (Data type: <class 'pandas.core.frame.DataFrame'>)
                         # 2. 인덱스 범위 (RangeIndex: 총 몇 개의 행(entries)이 있는지)
                         # 3. 각 열(Column)의 이름
                         # 4. 각 열에 포함된 "결측값이 아닌(Non-Null) 데이터의 개수"
                         # 5. 각 열의 "데이터 타입 (Dtype)"
                         # 6. 메모리 사용량 (memory usage)
                         # print() 함수를 사용하는 이유는 .info() 자체가 None을 반환하므로, 결과를 화면에 명시적으로 출력하기 위해서입니다.



print(train_data.describe()) # DataFrame의 `.describe()` 메서드를 호출하여 결과를 출력합니다.
                             # 이 메서드는 DataFrame 내의 "수치형(numerical) 데이터"를 가진 열에 대해
                             # 기본적인 통계 정보(개수, 평균, 표준편차, 최솟값, 분위수, 최댓값)를 계산하여 요약해 줍니다.
                             # 문자열이나 범주형 데이터를 가진 열은 기본적으로 이 요약에 포함되지 않습니다.














# Series 객체 생성 (딕셔너리처럼 인덱스와 값의 쌍으로 구성됨)
a = pd.Series([100, 200, 300], ['a', 'b', 'd']) # 'a', 'b', 'd'를 인덱스로, [100, 200, 300]을 값으로 갖는 Series 'a' 생성
b = pd.Series([101, 201, 301], ['a', 'b', 'k']) # 'a', 'b', 'k'를 인덱스로, [101, 201, 301]을 값으로 갖는 Series 'b' 생성
c = pd.Series([110, 210, 310], ['a', 'b', 'c']) # 'a', 'b', 'c'를 인덱스로, [110, 210, 310]을 값으로 갖는 Series 'c' 생성

# DataFrame 생성
# 여러 Series를 리스트 [a, b, c]로 묶어 pd.DataFrame()의 첫 번째 인수로 전달합니다.
# 이 경우, 각 Series는 DataFrame의 '행(Row)'이 됩니다.
print(pd.DataFrame(
    [a, b, c],      # Series 객체 a, b, c를 포함하는 리스트를 데이터로 사용합니다.
    index = [100, 101, 102]     # 생성될 DataFrame의 행 인덱스(Row label)를 [100, 101, 102]로 지정합니다.
)) # 생성된 DataFrame을 출력합니다. (변수에 할당하지 않고 바로 출력)














data = { # data라는 이름의 Python 딕셔너리를 생성합니다. 
         # 이 딕셔너리는 DataFrame을 만들기 위한 원천 데이터가 됩니다.
    "2015": [9904312, 3448737, 2890451, 2466052],  # 키("2015")는 열(Column) 이름이 되며, 값(List)은 해당 열의 데이터가 됩니다. (2015년 인구 데이터)
    "2010": [9631482, 3393191, 2632035, 2000002],  # 2010년 인구 데이터
    "2005": [9762546, 3512547, 2517680, 2456016],  # 2005년 인구 데이터
    "2000": [9853972, 3655437, 2466338, 2473990],  # 2000년 인구 데이터
    "지역": ["수도권", "경상권", "수도권", "경상권"], # 지역 구분 데이터
    "2010-2015 증가율":[0.0283, 0.0163, 0.0982,0.0141] # 2010년 대비 2015년 인구 증가율 데이터
}

columns =['지역','2000','2005','2010','2015', '2010-2015 증가율'] # DataFrame의 최종 열 순서를 지정하는 리스트를 생성합니다.
index = ['서울','부산','인천','대구'] # DataFrame의 행(Row) 인덱스(레이블)를 지정하는 리스트를 생성합니다.
df3 = pd.DataFrame(data, index=index, columns=columns) # DataFrame을 생성하여 변수 df3에 저장합니다.
                                                        # data: 사용할 원천 딕셔너리
                                                        # index: 사용할 행 인덱스 (도시 이름)
                                                        # columns: 사용할 열과 그 순서

# print(df3)









print(type(df3.columns)) # df3.columns 객체의 "자료형(Type)"을 출력합니다.
print(df3.columns)      # df3 DataFrame의 "열 인덱스 객체(Column Index)"를 출력합니다.    dtype 결과 : object
print(type(df3.index))  # df3.index 객체의 "자료형(Type)"을 출력합니다.
print(df3.index)        # df3 DataFrame의 "행 인덱스 객체(Row Index)"를 출력합니다.    dtype 결과 : object



df3.index.name = '도시'    # DataFrame의 '행 인덱스 자체'에 이름('도시')을 지정합니다. (출력 시 왼쪽 상단에 표시됨)
df3.columns.name = '특성'  # DataFrame의 '열 인덱스 자체'에 이름('특성')을 지정합니다. (출력 시 왼쪽 상단에 표시됨)
print(df3)



# # df3.values는 DataFrame에서 행과 열 레이블(인덱스, 컬럼 이름)을 제외한 순수한 데이터 값만을 NumPy 배열(ndarray) 형태로 반환합니다.
# print(type(df3.values)) # df3.values의 "타입(type)"을 출력합니다.





# df3.values는 DataFrame의 데이터만을 담고 있는 NumPy ndarray(N-차원 배열)를 반환합니다.
# 인덱스(index)와 열 이름(column names)은 제외됩니다.
# df3.values[0]은 이 배열의 첫 번째 행(즉, '서울' 행의 데이터)을 선택합니다.

print(type(df3.values[0])) # 첫 번째 행 데이터의 "타입"을 출력합니다.
                            # 이는 일반적으로 numpy.ndarray 타입이 됩니다.
print(df3.values[0])       # 첫 번째 행 데이터의 "값"을 출력합니다.
                            # 즉, 서울의 '지역', '2000'~'2015' 인구, '2010-2015 증가율'이 배열 형태로 출력됩니다.
                                                    
                            
                            
print(df3.T) # df3 DataFrame의 전치(Transpose)된 결과를 출력합니다.
             # .T 속성은 DataFrame의 행(Row)과 열(Column)을 서로 맞바꿉니다.
             # 즉, 기존의 행 인덱스('서울', '부산', ...)가 새 DataFrame의 "열 이름"이 되고,
             # 기존의 열 이름('지역', '2000', ...)이 새 DataFrame의 "행 인덱스"가 됩니다.
             
             
             

# df3.T: DataFrame의 행(index)과 열(columns)을 바꾼(Transpose/전치) 새로운 DataFrame을 반환합니다.
#        전치 후, 원래의 행 인덱스('서울', '부산' 등)는 열 이름이 되고, 원래의 열 이름('지역', '2000' 등)은 행 인덱스가 됩니다.
# ['서울']: 전치된 DataFrame (df3.T)에서 '서울' 열을 선택합니다.
#         전치되었기 때문에, 원래 DataFrame에서 '서울' 행에 있던 모든 데이터(Series)를 얻게 됩니다.
# .values: 선택된 Series의 데이터만을 NumPy 배열(ndarray) 형태로 추출합니다.
print(df3.T['서울'].values) # 전치된 DataFrame에서 '서울' 열(원래 '서울' 행)의 값들만 배열 형태로 출력합니다.





print(
    df3.T # 1. df3 DataFrame을 "전치(Transpose)"합니다. (T는 Transpose의 약자)
          #    전치하면 행(인덱스)과 열(컬럼)이 서로 바뀝니다.
          #    - 원래 인덱스('서울', '부산' 등)가 "새로운 열 이름"이 됩니다.
          #    - 원래 컬럼 이름('지역', '2000' 등)이 "새로운 행 인덱스"가 됩니다.
          #    
    ['서울']  # 2. 전치된 DataFrame(df3.T)에서 "'서울' 열"을 선택합니다.
             #    이 결과는 '서울'에 대한 모든 데이터(지역, 2000년 인구, 2005년 인구 등)를 포함하는 "Series"가 됩니다.
    ['2000'] # 3. 위에서 선택된 '서울' Series에서 "인덱스 '2000'"에 해당하는 "값"을 선택합니다.
             #    원래 DataFrame으로 치면, '서울' 행과 '2000' 열이 교차하는 지점의 값, 즉 2000년 서울 인구를 의미합니다.
) # 최종적으로 2000년 서울 인구 수치(9853972)를 출력합니다.




# df3['2010-2015 증가율'] : DataFrame에서 '2010-2015 증가율' 열을 선택합니다.
# 이 결과는 pandas Series 객체이며, 값은 [0.0283, 0.0163, 0.0982, 0.0141] 입니다.
# * 100 : 이 Series 객체에 100을 곱합니다. 
# pandas는 브로드캐스팅(broadcasting) 기능을 지원하여, Series의 모든 요소(값)에 100을 "한 번에" 곱합니다.
# 이로써 비율 형태의 증가율을 백분율(%) 형태로 변환합니다.
print(df3['2010-2015 증가율'] * 100) # 계산된 결과(백분율 형태의 증가율 Series)를 출력합니다.




# df3['2010-2015 증가율']을 선택합니다. (Series 객체)
# 이 Series의 모든 값에 "100을 곱합니다". (벡터 연산: 모든 요소에 대해 연산이 수행됨)
# 그 결과를 다시 "같은 열(df3['2010-2015 증가율'])에 할당"하여 데이터를 덮어씁니다.
#   (비율(예: 0.0283)을 퍼센트(예: 2.83)로 변환하는 작업입니다.)
df3['2010-2015 증가율'] = df3['2010-2015 증가율'] * 100
print(df3['2010-2015 증가율']) # 결과 확인







df3['비고'] = ['특별시', '광역시', '특례시', '특례시'] 
# 생성된 DataFrame (df3)에 '비고'라는 이름의 "새로운 열(Column)을 추가"합니다.
# 우변의 리스트 ['특별시', '광역시', '특례시', '특례시']는 df3의 각 행에 대응하는 데이터가 됩니다.
# DataFrame의 각 행 수(4개)와 리스트의 원소 수(4개)가 일치해야 합니다.

print(df3)   # 새로운 열이 추가된 최종 DataFrame을 화면에 출력합니다.



del df3['비고'] # Python의 내장 명령어인 del을 사용하여, 방금 생성한 '비고' 열(Column)을 DataFrame에서 삭제합니다.
print(df3) # '비고' 열이 삭제된 최종 DataFrame df3를 출력합니다.






df3['2005-2015 증가율'] = ( # '2005-2015 증가율'이라는 "새로운 열(Column)"을 df3에 추가하고 그 값을 할당합니다.
    (df3['2015'] - df3['2005']) # 2015년 인구에서 2005년 인구를 뺌 (인구 변화량 계산)
    / df3['2005']               # 인구 변화량을 2005년 인구로 나눔 (비율 계산, 예: 0.0123)
    * 100                       # 100을 곱하여 백분율(%)로 변환 (예: 1.23)
).round(2)                      # `.round(2)` 메서드를 사용하여 계산된 백분율을 소수점 둘째 자리까지 반올림합니다.
                                # Pandas는 Series 연산을 지원하여 각 행별로 위 계산을 한 번에 수행합니다 (벡터화 연산).

print(df3) # 결과 DataFrame 출력




del df3['2005-2015 증가율']
# Python의 내장 명령어인 del을 사용하여, 방금 생성한 '2005-2015 증가율' 열(Column)을 DataFrame에서 삭제합니다.
print(df3)






# ".loc[] 인덱서"를 사용하여 '광주'라는 "새로운 행 레이블"에 데이터를 할당합니다.
# DataFrame의 인덱스(도시 이름) 중 '광주'라는 레이블을 선택합니다.
# 만약 '광주'가 이미 존재하면 해당 행의 값이 "수정"되고, 존재하지 않으면 "새로운 행이 추가"됩니다.
# 할당되는 리스트의 값들은 "columns 리스트의 순서"('지역', '2000', ..., '2010-2015 증가율')에 맞게 순차적으로 들어갑니다.
df3.loc['광주'] = ['호남권', 2470000, 2456000, 2453000, 2460000, 1.00] 
print(df3) # 수정/추가된 DataFrame df3를 화면에 출력합니다.





print(df3['지역'])
# DataFrame df3에서 "대괄호([ ])"를 사용하여 '지역'이라는 열(Column)을 선택하고 그 내용을 출력합니다.
# 이는 "pandas Series" 객체로 반환됩니다.



print(type(df3['지역']))
# df3['지역']의 "타입"을 출력합니다.
# 단일 열을 선택했으므로 "pandas.core.series.Series" 타입이 출력됩니다.



print(df3.지역)
# df3 DataFrame에서 "'지역'이라는 이름의 열(Column)을 선택"하여 출력합니다.
# 열 선택 방식은 "`DataFrame.컬럼명`" 또는 `DataFrame['컬럼명']` 형태를 사용합니다.
# 선택된 열은 pandas의 "Series" 객체 형태로 반환됩니다.





# print(df3[['지역']])
# DataFrame에서 '지역'이라는 이름의 열(Column)만 선택합니다.
# "이중 대괄호 `[['지역']]`"를 사용하면 선택된 열이 "DataFrame" 형태로 반환됩니다.###########################
# (만약 단일 대괄호 `['지역']`을 사용하면 pandas Series 형태로 반환됩니다.)###########################
print(df3[['지역']]) # '지역' 열만을 포함하는 새로운 DataFrame을 출력합니다.




# df3[['지역']] : DataFrame에서 "두 겹의 대괄호"를 사용하여 '지역'이라는 열을 선택합니다.
# "Key Point": DataFrame에서 열을 선택할 때 리스트 형태(예: ['지역'])로 선택하면, 
# 결과는 "하나의 열을 포함하는 DataFrame"으로 반환됩니다. (Series가 아님!)#############################
print(type(df3[['지역']])) # 선택된 결과의 "타입"을 출력합니다.
                           # 결과는 <class 'pandas.core.frame.DataFrame'>이 됩니다.








print(df3[['2010', '2015']]) # DataFrame df3에서 "열 이름의 리스트"를 사용하여
                             # '2010' 열과 '2015' 열만 "선택(Selection)"하여 출력합니다.
                             # DataFrame에서 여러 열을 선택할 때는 "대괄호 안에 또 다른 대괄호"(`df3[[...]]`)를 사용해야 합니다.
                             # 결과는 새로운 DataFrame 형태로 반환됩니다.



# 위치적으로 맨 처음 열을 반환받기 위해 위치 인덱스를 사용해 봄.
# df3[0]은 컬럼명이 0인 컬럼을 찾으라는 의미인데, 컬럼명이 0인 컬럼은 없음. 따라서 위치 인덱스 사용 불가.
try: # 예외 처리(Exception Handling)를 시작합니다.
    df3[0] # DataFrame에서 "정수 0"을 인덱싱(indexing)하여 접근을 시도합니다.
           # pandas DataFrame에서 대괄호 `[]`를 사용하여 데이터를 선택할 때,
           # 기본적으로는 "열 이름(Column Label)"을 사용해야 합니다.
           # 이 DataFrame은 '지역', '2000', '2005' 등의 문자열 열 이름을 가지고 있으므로,
           # 정수 `0`은 유효한 열 이름이 아니기 때문에 "오류(KeyError)"가 발생합니다.
except Exception as e: # `try` 블록에서 오류(Exception)가 발생하면, 해당 오류 객체를 변수 `e`에 저장합니다.
    print(type(e))     # 발생한 오류 객체 `e`의 "타입"을 출력합니다.
                       # DataFrame에서 존재하지 않는 열 이름으로 접근 시 발생하는 오류 타입인
                       # `<class 'KeyError'>`가 출력될 것입니다.





# --- 슬라이싱을 이용한 행 선택 ---
print(df3[:'서울']) # DataFrame에 대괄호 `[]`를 사용하여 슬라이싱을 수행하면, 기본적으로 "행(Row)"을 선택합니다.
                      # 행 레이블(문자열 인덱스)을 사용하여 슬라이싱을 할 때,
                      # `[:'서울']`은 "시작 행(없으므로 처음부터)"부터 "'서울' 행까지"를 의미합니다.
                      # "중요": 레이블 슬라이싱에서는 끝나는 레이블('서울')이 "포함"됩니다.
                      # 따라서, 이 코드는 DataFrame의 첫 번째 행인 "'서울' 행만"을 선택하여 출력합니다.





# --- 행 슬라이싱 및 출력 ---
# DataFrame의 대괄호 `[]` 안에 '시작 행 레이블':'끝 행 레이블' 형식으로 "슬라이싱"을 수행합니다.
# 주의: pandas에서 "레이블(이름)"을 이용한 슬라이싱은 Python의 기본 리스트 슬라이싱과 다르게
# "끝 레이블을 포함"합니다. (End-point inclusive)
# df3['인천':'인천']는 '인천' 행에서 시작하여 '인천' 행에서 끝나는 슬라이싱으로, 
# 결과적으로 "'인천' 단일 행"을 선택합니다.
print(df3['인천':'인천']) # '인천' 행을 DataFrame 형식(2차원)으로 출력합니다.





# --- 행 슬라이싱 및 출력 ---
# DataFrame의 슬라이싱 [start:stop:step]은 기본적으로 "행(Row)"을 대상으로 작동합니다.
# 인덱싱이 아닌 슬라이싱(콜론 `:` 포함)을 사용하면 정수 위치 기반으로 행을 선택할 수 있습니다.
print(df3[:1]) # 첫 번째 행부터 (시작 인덱스 생략 = 0) 인덱스 1 "이전까지"의 행을 선택합니다.
               # 즉, 0번 행 하나만 선택합니다. (서울)
               # 결과는 1개의 행을 가진 DataFrame 형태입니다.

print(df3[0:1]) # 인덱스 0부터 인덱스 1 "이전까지"의 행을 선택합니다.
                # `df3[:1]`와 완전히 동일한 결과를 반환합니다.
                # 결과는 1개의 행을 가진 DataFrame 형태입니다.








# --- 행 슬라이싱 및 출력 ---
print(df3['부산':'인천']) # DataFrame에서 대괄호 `[]` 안에 "레이블(행 이름)을 이용한 슬라이싱"을 수행합니다.
                         # pandas는 행 인덱스가 문자열 레이블일 경우, 슬라이싱을 할 때 
                         # "시작 인덱스('부산')부터 끝 인덱스('인천')까지 모두 포함"하여 행을 선택합니다.
                         # 이는 Python 리스트의 슬라이싱([start:end-1])과 달리, 
                         # "끝 지점 레이블을 포함"한다는 중요한 특징이 있습니다.
                         
                         

# --- 행 선택 및 출력 ---
print(df3['대구':'대구']) # DataFrame에 "슬라이싱 구문(Slice Syntax)"을 사용하여 데이터를 선택합니다.
                         # DataFrame에서 슬라이싱을 사용할 때, 기본적으로 "행 인덱스(Row Label)"를 기준으로 동작합니다.
                         # '시작 레이블':'종료 레이블' 형태로 입력하며, "종료 레이블도 포함"됩니다.
                         # '대구' 행부터 '대구' 행까지 선택하므로, 결과적으로 "'대구' 행 하나만" 선택되어 새로운 DataFrame으로 반환됩니다.
                         # (단일 행을 선택하는 일반적인 방법은 df3.loc['대구'] 입니다.)






# --- 열 선택 및 출력 ---
print(df3['2015']) # DataFrame df3에서 대괄호 `[]` 안에 열 이름 '2015'를 전달하여 해당 열을 선택합니다.
                   # DataFrame에서 단일 열을 선택하면 그 결과는 "pandas Series" 객체가 됩니다.
                   # 이 Series에는 '2015'년 인구 데이터가 들어 있으며, 인덱스(서울, 부산, 인천, 대구)가 함께 출력됩니다.



# --- 데이터 추출 및 출력 ---
print(df3['2015']['부산']) # 이중 대괄호(Chain Indexing)를 사용하여 단일 값을 추출합니다.
                           # df3['2015']: DataFrame df3에서 "열 이름 '2015'"에 해당하는 "Series 객체"를 먼저 추출합니다.
                           # (결과: Series 형태로 된 2015년 인구 데이터)
                           # ['부산']: 앞서 추출된 Series 객체에서 "인덱스 '부산'"에 해당하는 "값"을 최종적으로 선택합니다.
                           # 즉, '2015년'의 '부산' 인구 수인 3448737을 선택합니다.



# --- 열 선택 및 출력 ---
print(df3[['2015']]) # DataFrame df3에서 "열 이름 리스트" `['2015']`를 사용하여 열을 선택합니다.
                     # "이중 대괄호" `[['...']]`를 사용하면 하나의 열을 선택하더라도
                     # 결과는 "Series"가 아닌 "DataFrame" 형태로 반환됩니다.
                     # 즉, '2015'년 인구 데이터 열만 포함된 새로운 DataFrame이 출력됩니다.



# --- 데이터 추출 및 출력 ---
# df3[['2015']] : DataFrame df3에서 "열 이름 '2015'"만을 "리스트"로 전달하여 선택합니다.
#                 -> 결과는 '2015' 열만 포함하는 "DataFrame" (Series가 아님)이 됩니다.
# [:]['부산':'부산'] : 위에서 선택된 '2015' 열의 DataFrame에 대해 "행 인덱싱(Slicing)"을 적용합니다.
#                 * pandas에서는 행 인덱싱(슬라이싱) 시 "시작 인덱스('부산')"와 "끝 인덱스('부산')"가 모두 포함됩니다.
#                 * 결국, '2015' 열에서 "인덱스 '부산'"에 해당하는 행을 선택합니다.
#                 -> 최종 결과는 '2015' 열과 '부산' 행의 값이 담긴 "DataFrame"이 됩니다.
print(df3[['2015']]['부산':'부산'])








# 이 코드는 이전에 생성된 pandas DataFrame df3에서 특정 열(Column) 두 개('2015', '2010')만 선택하여 
# 새로운 DataFrame df를 만들고 그 결과를 출력하는 예제입니다.
df = df3[['2015', '2010']] # DataFrame df3에서 "이중 대괄호 `[[...]]`"를 사용하여
                           # "'2015'" 열과 "'2010'" 열 두 개만 선택하여 새로운 DataFrame을 생성하고
                           # 그 결과를 변수 df에 저장합니다.
                           # 이중 대괄호 안에 열 이름(레이블)의 리스트를 전달하여 여러 열을 선택할 수 있습니다.
print(df) # 새로 생성된 DataFrame df를 출력합니다.






# --- 데이터 선택 및 출력 ---
# df3[['2005','2010']]
#  - df3에서 열 이름 리스트를 사용하여 "'2005'와 '2010' 두 개의 열"만 선택합니다.
#  - 이 결과는 새로운 DataFrame (Series가 아님)을 반환합니다.
# [...]['부산':'부산']
#  - 1단계에서 반환된 DataFrame에 대해 다시 대괄호 `[]`를 사용하여 슬라이싱(Slicing)을 적용합니다.
#  - DataFrame에서 인덱싱/슬라이싱을 할 때 문자열 인덱스 레이블을 사용하면 "행(Row)"을 선택합니다.
#  - 슬라이싱 `['부산':'부산']`은 '부산' 레이블을 가진 행부터 '부산' 레이블을 가진 행까지, 즉 "'부산' 행 하나"만 선택합니다.
#  - pandas의 레이블 슬라이싱(`start:end`)은 끝 인덱스도 "포함"합니다.
print(df3[['2005','2010']]['부산':'부산']) # 최종적으로 '부산' 행의 '2005', '2010' 열 데이터만 포함하는 DataFrame을 출력합니다.






# --- 행(Row) 삭제 ---
df3.drop( # DataFrame에서 행 또는 열을 제거하는 메서드를 호출합니다.
    index=['인천'] # index 매개변수를 사용하여 제거할 "행 인덱스(레이블)"를 지정합니다. 
                  # 여기서는 인덱스 '인천'에 해당하는 행을 제거합니다.
                  # (참고: axis=0이 기본값이며, 이는 행을 의미합니다.)
                  # "주의": 이 메서드는 원본 DataFrame(df3)을 직접 변경하지 않고,########################
                  # '인천' 행이 제거된 "새로운 DataFrame"을 반환합니다.
                  # 원본을 변경하려면 'inplace=True' 옵션을 추가해야 합니다.########################
)
print(df3) # 원본 DataFrame df3를 출력합니다.
           # 위에 drop()을 실행했지만, df3는 변경되지 않았기 때문에 '인천' 행이 그대로 포함된
           # 원래의 DataFrame이 출력될 것입니다.







# # --- 행 제거 (Drop) 작업 ---
# 1차 제거 시도 (원본 변경 X)
# index=['인천','대구']를 지정하여 '인천'과 '대구' 행을 DataFrame에서 "제거한 새로운 DataFrame"을 생성합니다.
# 그러나 이 결과를 "별도의 변수에 할당하지 않고" (df3 = ... 하지 않음)
# "inplace=False (기본값)" 이므로, "원본 df3는 변하지 않고" 제거된 결과는 사라집니다.
df3.drop(index=['인천','대구']) 

# 2차 제거 시도 (원본 변경 O)
# index=['부산']를 지정하여 '부산' 행을 제거합니다.
# "inplace=True"로 설정했기 때문에, `.drop()` 연산이 "원본 DataFrame df3에 즉시 반영되어" '부산' 행이 영구적으로 제거됩니다.
df3.drop(index=['부산'], inplace=True) 

print(df3) # 최종적으로 수정된 DataFrame df3의 내용을 출력합니다.








# --- 열 제거 (Drop Columns) ---
df3.drop(  # DataFrame에서 특정 행 또는 열을 제거하는 메서드를 호출합니다.
    columns=['2010-2015 증가율','2010'] # `columns` 인자에 "제거할 열 이름들"의 리스트를 전달합니다. 
                                        # '2010-2015 증가율' 열과 '2010' 열이 제거됩니다.
    # 참고: .drop() 메서드는 기본적으로 원본 DataFrame(df3)을 변경하지 않고,
    #       "제거된 열이 없는 새로운 DataFrame을 반환"합니다.
    #       (원본을 변경하려면 `inplace=True` 옵션을 추가해야 합니다.)
)
# 이 코드는 새로운 DataFrame을 변수에 할당하지 않았으므로, 
# 제거된 열이 반영된 DataFrame이 출력만 되고, 원본 df3는 그대로 유지됩니다.








# --- 데이터 삭제 ---
# 행 삭제 (axis=0)
df3.drop(['대구'], # 삭제할 대상의 "레이블(이름)"을 리스트로 지정합니다. (여기서는 행 이름 '대구')
         axis=0)  # "axis=0"은 "행(Row, Index)"을 따라 삭제하라는 의미입니다.
                  # 이 연산은 원본 df3를 변경하지 않고, '대구' 행이 제거된 "새로운 DataFrame"을 반환합니다.
                  # (반환된 DataFrame을 변수에 할당하지 않았으므로, 이 줄만으로는 아무것도 출력되거나 저장되지 않습니다.)

# 열 삭제 (axis=1)
df3.drop(['2010-2015 증가율'], # 삭제할 대상의 "레이블(이름)"을 리스트로 지정합니다. (여기서는 열 이름 '2010-2015 증가율')
         axis=1)             # "axis=1"은 "열(Column)"을 따라 삭제하라는 의미입니다.
                             # 마찬가지로 원본 df3를 변경하지 않고, 해당 열이 제거된 "새로운 DataFrame"을 반환합니다.
                             # (역시 반환된 DataFrame을 변수에 할당하지 않았습니다.)









# 위치 인덱싱 처럼 보이는 예제
# df를 만들때 index와 column을 명시 하지 않음.
# 이런경우, 기본 인덱스가 자동 생성됨(0부터 시작하는 인덱스를 생성) 순서가 아님 (위치랑은 아무 상관 없음)

# np.arange(12): 0부터 11까지의 정수(총 12개)를 갖는 1차원 배열을 생성합니다. (결과: [0, 1, 2, ..., 11])
# .reshape(3, 4): 위 1차원 배열을 3행 4열의 2차원 배열로 변형합니다.
# pd.DataFrame(...): 이 2차원 배열을 데이터로 사용하여 DataFrame을 생성합니다.
# 참고: 이 DataFrame은 열 이름(Column)과 행 이름(Index)이 지정되지 않았으므로, 
# 모두 0부터 시작하는 정수(0, 1, 2, 3)가 기본값으로 사용됩니다.
# (Column: 0, 1, 2, 3 / Index: 0, 1, 2)
df5 = pd.DataFrame(np.arange(12).reshape(3, 4)) 

df5[[1, 2]] # DataFrame에서 대괄호 `[]` 안에 "열 이름(Column Name)"의 리스트를 전달하여 여러 개의 열을 선택합니다.
            # 이 DataFrame은 열 이름이 기본 정수 0, 1, 2, 3이므로,
            # 열 이름 "1"과 열 이름 "2"에 해당하는 두 개의 열을 선택하여 새로운 DataFrame으로 반환합니다.
            # (pandas는 정수형 열 이름이더라도 `[]` 인덱싱 시 이를 "레이블(이름)"로 인식하여 열을 선택합니다.)







np.arange(12)      # numpy의 arange 함수를 사용하여 0부터 시작하여 11까지의 정수(총 12개)를 갖는
                   # 1차원 배열(ndarray)을 생성합니다. (Python의 range() 함수와 유사합니다.)
                   # 결과: array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])

np.arange(12).reshape(3, 4) # 첫 번째 실행 결과인 1차원 배열(0~11)을 가져와서
                            # .reshape(3, 4) 메서드를 호출하여 "3행 4열"의 2차원 배열로 형태를 변경합니다.
                            # 이 때, 배열에 있는 총 원소의 개수(12개)는 변경할 형태(3 * 4 = 12)와 일치해야 합니다.
                            # 결과: 
                            # array([[ 0,  1,  2,  3],
                            #        [ 4,  5,  6,  7],
                            #        [ 8,  9, 10, 11]])






